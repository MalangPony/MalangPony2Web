import { Vector2, Vector3 } from "./vectors.js";
import { AnimatedValue } from "./animator.js";
import { linear_map } from "./utils.js";

let container = document.getElementById("internal-map-container");
let image = document.getElementById("internal-map-image");
let canvas = document.getElementById("internal-map-canvas");

const bounds_pixel_basis=3000;

// Below object was generated by a python script with a manually-traced SVG file.
const bounds={
  main:[
    [1454.687,375.012],
    [538.989,1333.021],
    [1014.379,1647.769],
    [1414.077,1543.443],
    [1805.598,1790.242],
    [2426.705,895.675],
  ],
  lobby:[
    [515.391,1373.325],
    [145.950,1768.998],
    [878.651,2297.564],
    [962.339,2186.457],
    [1034.309,2234.465],
    [1461.171,1654.636],
    [1413.387,1626.344],
    [1024.453,1717.152],
  ],
  sub:[
    [2232.531,1273.204],
    [1808.914,1870.513],
    [2215.925,2122.918],
    [2622.622,1501.388],
  ],
  storage:[
    [2451.097,910.286],
    [2286.532,1130.432],
    [2711.542,1364.980],
    [2789.954,1242.628],
    [2722.894,1053.090],
  ],
  gallery:[
    [513.685,1384.504],
    [201.832,1719.795],
    [444.602,1896.904],
    [738.921,1530.108],
  ],
  regDesk:[
    [544.184,1749.208],
    [377.266,1936.545],
    [677.918,2157.650],
    [845.007,1961.000],
  ],
  signboard:[
    [1015.405,1606.620],
    [1052.223,1765.098],
    [1316.286,1704.645],
    [1292.831,1546.082],
  ],
  stage:[
    [1125.291,686.294],
    [872.420,952.719],
    [1050.168,1070.490],
    [1296.675,786.888],
  ],
  control:[
    [1453.141,362.109],
    [1272.217,548.724],
    [1407.181,632.804],
    [1590.433,431.961],
  ],
  vendor:[
    [1693.064,501.557],
    [1597.170,609.006],
    [2254.293,968.438],
    [2336.909,854.089],
  ],
  snack:[
    [1709.388,845.272],
    [1645.934,921.957],
    [1874.129,1049.950],
    [1937.057,972.092],
  ],
  seating:[
    [1516.050,739.384],
    [1061.327,1268.678],
    [1227.631,1376.435],
    [1326.721,1255.700],
    [1608.191,1427.777],
    [1867.906,1090.439],
    [1589.789,941.836],
    [1685.949,827.202],
  ],
  rest:[
    [2138.226,962.259],
    [1934.672,1245.325],
    [2092.368,1330.395],
    [2289.276,1044.339],
  ],
  drawing:[
    [1805.764,1372.101],
    [1568.555,1681.813],
    [1731.130,1786.882],
    [1964.926,1465.826],
  ],
  shrine:[
    [2062.248,1336.194],
    [1727.292,1794.811],
    [1812.592,1848.405],
    [2144.074,1381.435],
  ],
  restroom:[
    [1306.346,1907.072],
    [1045.904,2241.601],
    [1796.007,2780.955],
    [2041.570,2400.083],
  ],
  entrance:[
    [860.071,2263.804],
    [1060.758,2425.696],
    [1128.520,2339.638],
    [924.125,2177.661],
  ],
};
const manual_centers={
  storage:[2541.874,1127.869],
  seating:[1504.036,1110.799],
  drawing:[1794.221,1544.370],
  shrine:[1847.330,1708.523],
  entrance:[964.633,2273.246],
};



const zone_data={
  entrance:{
    name_ko:"입구",
    name_en:"Entrance",
    desc_ko:"",
    desc_en:"",
    category:"reg",
    priority:2
  },
  main:{
    name_ko:"메인 홀",
    name_en:"Main Hall",
    desc_ko:"",
    desc_en:"",
    category:"area",
    priority:1
  },
  lobby:{
    name_ko:"로비",
    name_en:"Lobby",
    desc_ko:"",
    desc_en:"",
    category:"area",
    priority:1
  },
  sub:{
    name_ko:"서브 홀",
    name_en:"Sub Hall",
    desc_ko:"소규모 패널과 활동이\n이루어지는 공간입니다.",
    desc_en:"A place for smaller\npanels and activities.",
    category:"sub",
    priority:2
  },
  storage:{
    name_ko:"창고",
    name_en:"Storage",
    desc_ko:"출입금지",
    desc_en:"Off limits.",
    category:"offlimit",
    priority:2
  },
  gallery:{
    name_ko:"아트 갤러리",
    name_en:"Art Gallery",
    desc_ko:"참가자들이 직접 제작한\n팬아트를 전시하는 공간입니다.",
    desc_en:"An art gallery of fanart\nsubmitted by other bronies.",
    category:"persistent",
    priority:2
  },
  regDesk:{
    name_ko:"등록 데스크",
    name_en:"Registration",
    desc_ko:"등록 데스크에서\n참가증과 특전을 수령하세요.",
    desc_en:"Redeem your badge and goodies\nfrom the registration desk.",
    category:"reg",
    priority:2
  },
  signboard:{
    name_ko:"사인보드",
    name_en:"Doodle Board",
    desc_ko:"낙서와 방명록을 위한\n거대한 캔버스!",
    desc_en:"A HUGE canvas for\nall your doodles and signatures.",
    category:"persistent",
    priority:2
  },
  stage:{
    name_ko:"메인 무대",
    name_en:"Main Stage",
    desc_ko:"말랑포니의 중심!",
    desc_en:"The center stage!",
    category:"main",
    priority:2
  },
  control:{
    name_ko:"본부석",
    name_en:"HQ",
    desc_ko:"스태프 전용 공간입니다.",
    desc_en:"Staff-only area.",
    category:"offlimit",
    priority:2
  },
  vendor:{
    name_ko:"부스 존",
    name_en:"Vendor Zone",
    desc_ko:"부스에서 포니 굿즈를 구매하세요!",
    desc_en:"Check out all the pony merch\nat the Vendor Zone!",
    category:"vendor",
    priority:2
  },
  snack:{
    name_ko:"스낵 바",
    name_en:"Snack Bar",
    desc_ko:"출출하신 분들을 위해\n먹을것, 마실것이 준비되어 있습니다.",
    desc_en:"Some food and drinks\nfor the hungry and thirsty.",
    category:"persistent",
    priority:2
  },
  seating:{
    name_ko:"메인 관중석",
    name_en:"Main Seating",
    desc_ko:"",
    desc_en:"",
    category:"main",
    priority:2
  },
  rest:{
    name_ko:"휴식 공간",
    name_en:"Resting Lounge",
    desc_ko:"휴식 및 담소가 가능한 공간입니다.",
    desc_en:"A place to rest and chat.",
    category:"persistent",
    priority:2
  },
  drawing:{
    name_ko:"자유 그림 코너",
    name_en:"Doodle Table",
    desc_ko:"테이블에 둘러앉아\n자유롭게 포니를 그려봐요!",
    desc_en:"A free drawing table for everypony!",
    category:"persistent",
    priority:2
  },
  shrine:{
    name_ko:"굿즈 전시대",
    name_en:"Merch Shrine",
    desc_ko:"누구나 포니 굿즈를 가져와서\n전시할 수 있는 공간입니다.",
    desc_en:"A place to show off\nyour pony merch.",
    category:"persistent",
    priority:2
  },
  restroom:{
    name_ko:"화장실",
    name_en:"Restrooms",
    desc_ko:"",
    desc_en:"",
    category:"restroom",
    priority:2
  },
};


let category_data={
  base:{
    color_border:"#FFF",
    color_fill:"#FFF",
    
    color_title_fill_active:"#FFF",
    color_title_fill_inactive:"#AAA",
    
    color_title_stroke_active:"#000",
    color_title_stroke_inactive:"#555",
    
    alpha_border_active:80,
    alpha_border_inactive:50,
    
    alpha_fill_active:50,
    alpha_fill_inactive:20,
    
    alpha_title_active:100,
    alpha_title_inactive:100,
  },
  
  area:{ //--template-malang-TWI --template-malang-TS
    color_border:"#AD8CD9",
    color_fill:"#765C99",
    alpha_title_inactive:0,
  },
  main:{ //--color-timetable-panel-main
    color_border:"#afe0ff",
    color_fill:"#afe0ff",
  },
  sub:{ //--color-timetable-panel-open
    color_border:"#ffd1a9",
    color_fill:"#ffd1a9",
  },
  persistent:{ //--color-timetable-long-running
    color_border:"#AFFAD7",
    color_fill:"#AFFAD7",
  },
  reg:{ //--color-timetable-event-critical
    color_border:"#F8FAB5",
    color_fill:"#F8FAB5",
  },
  vendor:{ //--color-timetable-vendor-main
    color_border:"#FFCCFF",
    color_fill:"#FFCCFF",
  },
  restroom:{
    color_border:"#DDD",
    color_fill:"#DDD",
  },
  offlimit:{
    color_border:"#C33",
    color_fill:"#C33",
  }
};
// Copy all non-existing keys from ["base"]
for (const k in category_data){
  if (k=="base") continue;
  for (const d in category_data["base"]){
    if (category_data[k][d]===undefined){
      category_data[k][d]=category_data["base"][d];
    }
  }
}

let current_lang="";
export function set_lang(l){
  current_lang=l;
}


let paths={};
function recalculate_paths(){
  paths={};
  for (const k in bounds){
    let p2d=new Path2D();
    let coords=bounds[k];
    for (let i=0;i<coords.length;i++){
      let x=coords[i][0]/bounds_pixel_basis*current_size;
      let y=coords[i][1]/bounds_pixel_basis*current_size;
      if (i==0) p2d.moveTo(x,y);
      else p2d.lineTo(x,y);
    }
    p2d.closePath();
    paths[k]=p2d;
  }
}

let centers={};
function recalculate_centers(){
  centers={};
  for (const k in bounds){
    if (manual_centers[k] !== undefined){
      centers[k]=[
        manual_centers[k][0]/bounds_pixel_basis*current_size,
        manual_centers[k][1]/bounds_pixel_basis*current_size,
      ];
    }else{
      let coords=bounds[k];
      let maxX=-Infinity;
      let maxY=-Infinity;
      let minX=Infinity;
      let minY=Infinity;
      for (let i=0;i<coords.length;i++){
        let x=coords[i][0]/bounds_pixel_basis*current_size;
        let y=coords[i][1]/bounds_pixel_basis*current_size;
        if (x>maxX) maxX=x;
        if (x<minX) minX=x;
        if (y>maxY) maxY=y;
        if (y<minY) minY=y;
      }
      centers[k]=[(minX+maxX)/2.0,(minY+maxY)/2.0];
    }
  }
}

let current_size=0;
// All UI elements were sized using a canvas of 700px in size,
// So if the canvas has a different size, we must scale the fonts accordingly.
// BUT don't resize it to be too small.
let font_size_muliplier=1.0;
function handle_resize(){
  current_size=container.clientWidth;
  canvas.width=current_size;
  canvas.height=current_size;
  font_size_muliplier=current_size/700.0;
  if (font_size_muliplier<0.8) font_size_muliplier=0.8;
  recalculate_paths();
  recalculate_centers();
}

let rso = new ResizeObserver(handle_resize);
rso.observe(container);
handle_resize();

const sc2d = canvas.getContext("2d");

let selection_progress={};
for (const k in bounds){
  let av=new AnimatedValue(0.0);
  av.duration=0.5;
  av.exponent=3.0;
  av.ease_out=true;
  selection_progress[k]=av;
}

// Last selected area is at the end
let selection_sorted_keys=[];
for (const k in bounds){
  selection_sorted_keys.push(k);
}

// AV of the 'focus' - will ramp up to 1.0 when ANYTHING is selected.
let focusAV = new AnimatedValue(0.0);
focusAV.duration=1.0;
focusAV.exponent=3.0;
focusAV.ease_out=true;
focusAV.ease_in=false;

let mouse_bounds_check={};
container.addEventListener("mousemove",(e)=>{
  let bbox=container.getBoundingClientRect();
  let localX=e.clientX-bbox.left;
  let localY=e.clientY-bbox.top;
  
  // Actual bounds check
  let mbc_last=mouse_bounds_check;
  mouse_bounds_check={};
  for (const k in bounds){
    mouse_bounds_check[k] = sc2d.isPointInPath(paths[k],localX,localY);
  }
  
  // Calculate max priority
  let max_priority=-Infinity;
  for (const k in bounds){
    if (mouse_bounds_check[k]){
      if (zone_data[k].priority>max_priority) max_priority=zone_data[k].priority;
    }
  }
  // Filter out lower-priority zones
  for (const k in bounds){
    if (zone_data[k].priority<max_priority){
      mouse_bounds_check[k] = false;
    }
  }
  
  // Transition check
  for (const k in bounds){
    let was_hit = mbc_last[k];
    let hit = mouse_bounds_check[k];
    
    if (was_hit && (!hit)){
      selection_progress[k].animate_to(0.0);
    }
    if ((!was_hit) && hit){
      selection_progress[k].animate_to(1.0);
      
      selection_sorted_keys.splice(selection_sorted_keys.indexOf(k),1);
      selection_sorted_keys.push(k);
    }
  }
  
  // Check if anything was hit
  let any_hit=false;
  let any_hit_prev=false;
  for (const k in bounds){
    if (mouse_bounds_check[k]) any_hit=true;
    if (mbc_last[k]) any_hit_prev=true;
  }
  if (any_hit) container.style.cursor="pointer";
  else container.style.cursor="unset";
  
  if ((!any_hit_prev) && any_hit) focusAV.animate_to(1.0);
  if (any_hit_prev && (!any_hit)) focusAV.animate_to(0.0);
});
container.addEventListener("mouseleave",(e)=>{
  for (const k in bounds){
    mouse_bounds_check[k] = false;
    selection_progress[k].animate_to(0.0);
  }
});

const font_title="bold 24px NPS";
const scale_inactive_title=0.7;
const delta_y_inactive_title=-3;
const delta_y_active_title=-20;
const stroke_title=6;

const font_desc="normal 16px NPS";
const delta_y_desc=+30;
const line_height_desc=20;
const stroke_desc=6;

function color_with_alpha(color,alpha){
  return "rgb(from "+color+" r g b / "+alpha+"%)";
}
function colormix(a,b,fac){
  return "color-mix(in srgb, "+a+" "+(100-fac*100)+"%, "+b+")";
}

const sine_period_seconds=2.0;
let sine_phase=0;
function update_canvas(dt){
  
  sine_phase+=dt*(2*Math.PI/sine_period_seconds);
  sine_phase = sine_phase % (2*Math.PI);
  let sine_value=Math.sin(sine_phase);
  for (const k in bounds){
    selection_progress[k].tick(dt);
  }
  focusAV.tick(dt);
  
  sc2d.clearRect(0,0,current_size,current_size);
  
  sc2d.miterLimit=2;
  sc2d.lineJoin="round";
  
  
  let focus=focusAV.calculate_value();
  //console.log(sp_max);
  for (const k in bounds){
    let p=paths[k];
    let sp=selection_progress[k].calculate_value();
    let focus_factor=1-Math.max(focus-sp,0);
    let fam = 0.6+0.4*focus_factor; // Focus Alpha Multiplier
    
    let cd=category_data[zone_data[k].category];
    const color_border= cd.color_border;
    const color_fill=cd.color_fill;
    const alpha_inactive_border=cd.alpha_border_inactive;
    const alpha_active_border=cd.alpha_border_active;
    const alpha_inactive_fill=cd.alpha_fill_inactive;
    const alpha_active_fill=cd.alpha_fill_active;
    
    // bounds stroke
    sc2d.lineWidth = 2;
    sc2d.strokeStyle = color_with_alpha(color_border,
       linear_map(0,1,sp,alpha_inactive_border,alpha_active_border)*fam);
    sc2d.stroke(p);
    
    // bounds fill
    sc2d.fillStyle=color_with_alpha(color_fill,
       linear_map(0,1,sp,alpha_inactive_fill,alpha_active_fill)*fam);
    sc2d.fill(p);
  }
  
  
  for (const k of selection_sorted_keys){
    let c=centers[k];
    let x=c[0];
    let y=c[1];
    let sp=selection_progress[k].calculate_value();
    let focus_factor=1-Math.max(focus-sp,0);
    
    const ata=category_data[zone_data[k].category].alpha_title_active;
    const ati=category_data[zone_data[k].category].alpha_title_inactive;
    const alpha_title=linear_map(0,1,sp,ati,ata);
    
    const ctfa=category_data[zone_data[k].category].color_title_fill_active;
    const ctfi=category_data[zone_data[k].category].color_title_fill_inactive;
    const ctf=color_with_alpha(colormix(ctfi,ctfa,focus_factor),alpha_title);
    const ctsa=category_data[zone_data[k].category].color_title_stroke_active;
    const ctsi=category_data[zone_data[k].category].color_title_stroke_inactive;
    const cts=color_with_alpha(colormix(ctsi,ctsa,focus_factor),alpha_title);
    
    let text=zone_data[k]["name_"+current_lang];
    let desc=zone_data[k]["desc_"+current_lang];
    
    // Title
    let dy=linear_map(0,1,sp,delta_y_inactive_title,delta_y_active_title);
    dy+=3*sine_value*sp;
    
    let scale=linear_map(0,1,sp,scale_inactive_title,1.0);
    
    sc2d.font=font_title;
    sc2d.textAlign="center";
    sc2d.textBaseline="middle";
    
    // Shadow
    if (sp>0.0001){
      let r_mult=(1+sp*sine_value*0.08)*scale;
      sc2d.beginPath();
      sc2d.ellipse(
        x,y+10*font_size_muliplier,
        30*r_mult*font_size_muliplier,
        10*r_mult*font_size_muliplier,
        0,0,2*Math.PI);
      sc2d.fillStyle=color_with_alpha("#000000",sp*25);
      sc2d.fill();
    }
    
    sc2d.resetTransform();
    sc2d.translate(x,y+dy);
    sc2d.scale(scale*font_size_muliplier,scale*font_size_muliplier);
    
    // Title Stroke
    sc2d.lineWidth = stroke_title;
    sc2d.strokeStyle = cts;
    sc2d.strokeText(text,0,0);
    
    // Title Fill
    sc2d.fillStyle=ctf;
    sc2d.fillText(text,0,0);
    sc2d.resetTransform();
    
    if (sp>0.0001){
      // Description
      sc2d.font=font_desc;
      sc2d.textAlign="center";
      sc2d.textBaseline="alphabetic";
      sc2d.resetTransform();
      sc2d.translate(x,y+delta_y_desc);
      sc2d.scale(font_size_muliplier,font_size_muliplier);
      
      let dy=0;
      let lines=desc.split("\n");
      for (let line of lines){
        line=line.trim();
        
        // Description Stroke
        sc2d.lineWidth = stroke_desc;
        sc2d.strokeStyle = color_with_alpha(cts,sp*100);
        sc2d.strokeText(line,0,dy);
        
        // Description Fill
        sc2d.fillStyle=color_with_alpha(ctf,sp*100);
        sc2d.fillText(line,0,dy);
        
        dy+=line_height_desc;
      }
      sc2d.resetTransform();
    }
    
  }
}


// This should be called every frame, from main JS.
export function animationTick(dt){
  
  update_canvas(dt);
}
