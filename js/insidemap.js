import { Vector2, Vector3 } from "./vectors.js";
import { AnimatedValue } from "./animator.js";
import { linear_map } from "./utils.js";

let container = document.getElementById("internal-map-container");
let image = document.getElementById("internal-map-image");
let canvas = document.getElementById("internal-map-canvas");

const bounds_pixel_basis=3000;

// Below object was generated by a python script with a manually-traced SVG file.
const bounds={
  /*
  main:[
    [1438.123,308.962],
    [495.021,1310.953],
    [1005.406,1649.787],
    [1402.276,1551.636],
    [1793.172,1800.000],
    [2473.400,866.288],
  ],
  lobby:[
    [475.562,1327.711],
    [101.389,1730.853],
    [931.812,2331.944],
    [1477.381,1631.878],
    [1395.304,1578.770],
    [994.577,1672.916],
  ],*/
  sub:[
    [2252.281,1223.909],
    [1820.172,1820.172],
    [2247.453,2097.784],
    [2660.251,1460.483],
  ],
  storage:[
    [2491.269,861.805],
    [2249.867,1199.768],
    [2667.493,1441.170],
    [2819.576,1204.596],
    [2744.742,992.163],
  ],
  gallery:[
    [475.562,1344.610],
    [159.325,1692.229],
    [386.243,1856.382],
    [707.308,1499.107],
  ],
  regDesk:[
    [528.671,1742.923],
    [371.759,1916.733],
    [654.200,2119.510],
    [806.283,1936.045],
  ],
  signboard:[
    [1011.475,1658.432],
    [1028.373,1716.369],
    [1308.399,1651.190],
    [1289.087,1595.668],
  ],
  stage:[
    [1127.348,634.887],
    [854.563,922.156],
    [1074.239,1059.755],
    [1342.196,760.417],
  ],
  control:[
    [1431.514,299.339],
    [1257.705,482.804],
    [1400.132,562.467],
    [1576.356,371.759],
  ],
  vendor:[
    [1711.541,451.422],
    [1624.636,552.811],
    [2257.110,900.430],
    [2344.014,789.385],
  ],
  snack:[
    [1725.747,800.569],
    [1666.003,873.969],
    [1891.323,996.871],
    [1947.653,918.350],
  ],
  seating:[
    [1495.306,681.081],
    [1032.717,1206.828],
    [1252.916,1345.093],
    [1346.800,1235.847],
    [1592.603,1389.474],
    [1874.254,1034.424],
    [1630.157,892.746],
    [1710.384,803.983],
  ],
  rest:[
    [2145.662,894.453],
    [1916.928,1191.465],
    [2091.039,1295.591],
    [2314.652,986.629],
  ],
  drawing:[
    [1797.440,1322.902],
    [1555.050,1638.692],
    [1735.989,1756.473],
    [1978.379,1423.613],
  ],
  shrine:[
    [2073.969,1324.609],
    [1747.938,1773.542],
    [1797.440,1802.561],
    [2125.178,1348.507],
  ],
  restroom:[
    [1295.591,1881.082],
    [1034.424,2219.062],
    [1783.784,2749.930],
    [2031.295,2370.982],
  ],
};


let paths={};
function recalculate_paths(){
  paths={};
  for (const k in bounds){
    let p2d=new Path2D();
    let coords=bounds[k];
    for (let i=0;i<coords.length;i++){
      let x=coords[i][0]/bounds_pixel_basis*current_size;
      let y=coords[i][1]/bounds_pixel_basis*current_size;
      if (i==0) p2d.moveTo(x,y);
      else p2d.lineTo(x,y);
    }
    p2d.closePath();
    paths[k]=p2d;
  }
}

let centers={};
function recalculate_centers(){
  centers={};
  for (const k in bounds){
    let coords=bounds[k];
    let avgX=0;
    let avgY=0;
    for (let i=0;i<coords.length;i++){
      let x=coords[i][0]/bounds_pixel_basis*current_size;
      let y=coords[i][1]/bounds_pixel_basis*current_size;
      avgX+=x/coords.length;
      avgY+=y/coords.length;
    }
    centers[k]=[avgX,avgY];
  }
}

let current_size=0;
function handle_resize(){
  current_size=container.clientWidth;
  canvas.width=current_size;
  canvas.height=current_size;
  recalculate_paths();
  recalculate_centers();
}

let rso = new ResizeObserver(handle_resize);
rso.observe(container);
handle_resize();

const sc2d = canvas.getContext("2d");

let selection_progress={};
for (const k in bounds){
  let av=new AnimatedValue(0.0);
  av.duration=0.5;
  av.exponent=3.0;
  av.ease_out=true;
  selection_progress[k]=av;
}

// Last selected area is at the end
let selection_sorted_keys=[];
for (const k in bounds){
  selection_sorted_keys.push(k);
}

let mouse_bounds_check={};
container.addEventListener("mousemove",(e)=>{
  let bbox=container.getBoundingClientRect();
  let localX=e.clientX-bbox.left;
  let localY=e.clientY-bbox.top;
  let any_hit=false;
  for (const k in bounds){
    let was_hit = mouse_bounds_check[k];
    
    let hit = sc2d.isPointInPath(paths[k],localX,localY);
    
    mouse_bounds_check[k] = hit;
    if (hit) any_hit=true;
    if (was_hit && (!hit)){
      selection_progress[k].animate_to(0.0);
    }
    if ((!was_hit) && hit){
      selection_progress[k].animate_to(1.0);
      
      selection_sorted_keys.splice(selection_sorted_keys.indexOf(k),1);
      selection_sorted_keys.push(k);
    }
  }
  if (any_hit) container.style.cursor="pointer";
  else container.style.cursor="unset";
});
container.addEventListener("mouseleave",(e)=>{
  for (const k in bounds){
    mouse_bounds_check[k] = false;
    selection_progress[k].animate_to(0.0);
  }
});

// Hex RGB values
const color_border="#AD8CD9";
const color_fill="#AD8CD9";
const color_title_fill="#FFF";
const color_title_stroke="#000";

// Percentage values
const alpha_inactive_border=50;
const alpha_active_border=80;
const alpha_inactive_fill=20;
const alpha_active_fill=50;

const font_title="bold 24px NPS";
const scale_inactive_title=0.7;
const delta_y_inactive_title=0;
const delta_y_active_title=-15;
const stroke_title=5;

const font_desc="normal 16px NPS";

function color_with_alpha(color,alpha){
  return "rgb(from "+color+" r g b / "+alpha+"%)";
}


function update_canvas(){
  
  sc2d.clearRect(0,0,current_size,current_size);
  
  sc2d.miterLimit=2;
  sc2d.lineJoin="round";
  
  for (const k in bounds){
    let p=paths[k];
    let sp=selection_progress[k].calculate_value();
    
    // bounds stroke
    sc2d.lineWidth = 2;
    sc2d.strokeStyle = color_with_alpha(color_border,
       linear_map(0,1,sp,alpha_inactive_border,alpha_active_border));
    sc2d.stroke(p);
    
    // bounds fill
    sc2d.fillStyle=color_with_alpha(color_fill,
       linear_map(0,1,sp,alpha_inactive_fill,alpha_active_fill));
    sc2d.fill(p);
  }
  
  sc2d.resetTransform();
  for (const k of selection_sorted_keys){
    let c=centers[k];
    let sp=selection_progress[k].calculate_value();
    
    // Title
    let dy=linear_map(0,1,sp,delta_y_inactive_title,delta_y_active_title);
    sc2d.translate(c[0],c[1]+dy);
    let scale=linear_map(0,1,sp,scale_inactive_title,1.0);
    sc2d.scale(scale,scale);
    sc2d.font=font_title;
    sc2d.textAlign="center";
    sc2d.textBaseline="middle";
    
    // Title Stroke
    sc2d.lineWidth = stroke_title;
    sc2d.strokeStyle = color_title_stroke;
    sc2d.strokeText(k,0,0);
    
    // Title Fill
    sc2d.fillStyle=color_title_fill;
    sc2d.fillText(k,0,0);
    sc2d.resetTransform();
  }
}


// This should be called every frame, from main JS.
export function animationTick(dt){
  for (const k in bounds){
    selection_progress[k].tick(dt);
  }
  update_canvas();
}
