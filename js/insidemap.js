import { Vector2, Vector3 } from "./vectors.js";
import { AnimatedValue } from "./animator.js";
import { linear_map } from "./utils.js";

let container = document.getElementById("internal-map-container");
let image = document.getElementById("internal-map-image");
let canvas = document.getElementById("internal-map-canvas");

const bounds_pixel_basis=3000;

// Below object was generated by a python script with a manually-traced SVG file.
const bounds={
  
  main:[
    [1438.123,308.962],
    [495.021,1310.953],
    [1005.406,1649.787],
    [1402.276,1551.636],
    [1793.172,1800.000],
    [2473.400,866.288],
  ],
  lobby:[
    [475.562,1327.711],
    [101.389,1730.853],
    [931.812,2331.944],
    [1477.381,1631.878],
    [1395.304,1578.770],
    [994.577,1672.916],
  ],
  sub:[
    [2252.281,1223.909],
    [1820.172,1820.172],
    [2247.453,2097.784],
    [2660.251,1460.483],
  ],
  storage:[
    [2491.269,861.805],
    [2249.867,1199.768],
    [2667.493,1441.170],
    [2819.576,1204.596],
    [2744.742,992.163],
  ],
  gallery:[
    [475.562,1344.610],
    [159.325,1692.229],
    [386.243,1856.382],
    [707.308,1499.107],
  ],
  regDesk:[
    [528.671,1742.923],
    [371.759,1916.733],
    [654.200,2119.510],
    [806.283,1936.045],
  ],
  signboard:[
    [1011.475,1658.432],
    [1028.373,1716.369],
    [1308.399,1651.190],
    [1289.087,1595.668],
  ],
  stage:[
    [1127.348,634.887],
    [854.563,922.156],
    [1074.239,1059.755],
    [1342.196,760.417],
  ],
  control:[
    [1431.514,299.339],
    [1257.705,482.804],
    [1400.132,562.467],
    [1576.356,371.759],
  ],
  vendor:[
    [1711.541,451.422],
    [1624.636,552.811],
    [2257.110,900.430],
    [2344.014,789.385],
  ],
  snack:[
    [1725.747,800.569],
    [1666.003,873.969],
    [1891.323,996.871],
    [1947.653,918.350],
  ],
  seating:[
    [1495.306,681.081],
    [1032.717,1206.828],
    [1252.916,1345.093],
    [1346.800,1235.847],
    [1592.603,1389.474],
    [1874.254,1034.424],
    [1630.157,892.746],
    [1710.384,803.983],
  ],
  rest:[
    [2145.662,894.453],
    [1916.928,1191.465],
    [2091.039,1295.591],
    [2314.652,986.629],
  ],
  drawing:[
    [1797.440,1322.902],
    [1555.050,1638.692],
    [1735.989,1756.473],
    [1978.379,1423.613],
  ],
  shrine:[
    [2073.969,1324.609],
    [1747.938,1773.542],
    [1797.440,1802.561],
    [2125.178,1348.507],
  ],
  restroom:[
    [1295.591,1881.082],
    [1034.424,2219.062],
    [1783.784,2749.930],
    [2031.295,2370.982],
  ],
};


const zone_data={
  main:{
    name_ko:"메인 홀",
    name_en:"Main Hall",
    desc_ko:"",
    desc_en:"",
    category:"area",
    priority:1
  },
  lobby:{
    name_ko:"로비",
    name_en:"Lobby",
    desc_ko:"",
    desc_en:"",
    category:"area",
    priority:1
  },
  sub:{
    name_ko:"서브 홀",
    name_en:"Sub Hall",
    desc_ko:"소규모 패널과 활동이\n이루어지는 공간입니다.",
    desc_en:"A place for smaller\npanels and activities.",
    category:"sub",
    priority:2
  },
  storage:{
    name_ko:"창고",
    name_en:"Storage",
    desc_ko:"출입금지",
    desc_en:"Off limits.",
    category:"offlimit",
    priority:2
  },
  gallery:{
    name_ko:"아트 갤러리",
    name_en:"Art Gallery",
    desc_ko:"참가자들이 직접 제작한\n팬아트를 전시하는 공간입니다.",
    desc_en:"An art gallery of fanart\nsubmitted by other bronies.",
    category:"persistent",
    priority:2
  },
  regDesk:{
    name_ko:"등록 데스크",
    name_en:"Registration",
    desc_ko:"등록 데스크에서\n참가증과 특전을 수령하세요.",
    desc_en:"Redeem your badge and goodies\nfrom the registration desk.",
    category:"reg",
    priority:2
  },
  signboard:{
    name_ko:"사인보드",
    name_en:"Doodle Board",
    desc_ko:"낙서와 방명록을 위한\n거대한 캔버스!",
    desc_en:"A HUGE canvas for\nall your doodles and signatures.",
    category:"persistent",
    priority:2
  },
  stage:{
    name_ko:"메인 무대",
    name_en:"Main Stage",
    desc_ko:"말랑포니의 중심!",
    desc_en:"The center stage!",
    category:"main",
    priority:2
  },
  control:{
    name_ko:"본부석",
    name_en:"HQ",
    desc_ko:"스태프 전용 공간입니다.",
    desc_en:"Staff-only area.",
    category:"offlimit",
    priority:2
  },
  vendor:{
    name_ko:"부스 존",
    name_en:"Vendor Zone",
    desc_ko:"부스에서 포니 굿즈를 구매하세요!",
    desc_en:"Check out all the pony merch\nat the Vendor Zone!",
    category:"vendor",
    priority:2
  },
  snack:{
    name_ko:"스낵 바",
    name_en:"Snack Bar",
    desc_ko:"출출하신 분들을 위해\n먹을것, 마실것이 준비되어 있습니다.",
    desc_en:"Some food and drinks\nfor the hungry and thirsty.",
    category:"persistent",
    priority:2
  },
  seating:{
    name_ko:"메인 관중석",
    name_en:"Main Seating",
    desc_ko:"",
    desc_en:"",
    category:"main",
    priority:2
  },
  rest:{
    name_ko:"휴식 공간",
    name_en:"Resting Lounge",
    desc_ko:"휴식 및 담소가 가능한 공간입니다.",
    desc_en:"A place to rest and chat.",
    category:"persistent",
    priority:2
  },
  drawing:{
    name_ko:"자유 그림 코너",
    name_en:"Doodle Table",
    desc_ko:"테이블에 둘러앉아\n자유롭게 포니를 그려봐요!",
    desc_en:"A free drawing table for everypony!",
    category:"persistent",
    priority:2
  },
  shrine:{
    name_ko:"굿즈 전시대",
    name_en:"Merch Shrine",
    desc_ko:"누구나 포니 굿즈를 가져와서\n전시할 수 있는 공간입니다.",
    desc_en:"A place to show off\nyour pony merch.",
    category:"persistent",
    priority:2
  },
  restroom:{
    name_ko:"화장실",
    name_en:"Restrooms",
    desc_ko:"",
    desc_en:"",
    category:"restroom",
    priority:2
  },
};


let category_data={
  base:{
    color_border:"#FFF",
    color_fill:"#FFF",
    
    color_title_fill_active:"#FFF",
    color_title_fill_inactive:"#AAA",
    
    color_title_stroke_active:"#000",
    color_title_stroke_inactive:"#333",
    
    alpha_border_active:80,
    alpha_border_inactive:50,
    
    alpha_fill_active:50,
    alpha_fill_inactive:20,
    
    alpha_title_active:100,
    alpha_title_inactive:100,
  },
  
  area:{ //--template-malang-TWI --template-malang-TS
    color_border:"#AD8CD9",
    color_fill:"#765C99",
    alpha_title_inactive:0,
  },
  main:{ //--color-timetable-panel-main
    color_border:"#afe0ff",
    color_fill:"#afe0ff",
  },
  sub:{ //--color-timetable-panel-open
    color_border:"#ffd1a9",
    color_fill:"#ffd1a9",
  },
  persistent:{ //--color-timetable-long-running
    color_border:"#AFFAD7",
    color_fill:"#AFFAD7",
  },
  reg:{ //--color-timetable-event-critical
    color_border:"#F8FAB5",
    color_fill:"#F8FAB5",
  },
  vendor:{ //--color-timetable-vendor-main
    color_border:"#FFCCFF",
    color_fill:"#FFCCFF",
  },
  restroom:{
    color_border:"#DDD",
    color_fill:"#DDD",
  },
  offlimit:{
    color_border:"#C33",
    color_fill:"#C33",
  }
};
// Copy all non-existing keys from ["base"]
for (const k in category_data){
  if (k=="base") continue;
  for (const d in category_data["base"]){
    if (category_data[k][d]===undefined){
      category_data[k][d]=category_data["base"][d];
    }
  }
}

let current_lang="";
export function set_lang(l){
  current_lang=l;
}


let paths={};
function recalculate_paths(){
  paths={};
  for (const k in bounds){
    let p2d=new Path2D();
    let coords=bounds[k];
    for (let i=0;i<coords.length;i++){
      let x=coords[i][0]/bounds_pixel_basis*current_size;
      let y=coords[i][1]/bounds_pixel_basis*current_size;
      if (i==0) p2d.moveTo(x,y);
      else p2d.lineTo(x,y);
    }
    p2d.closePath();
    paths[k]=p2d;
  }
}

let centers={};
function recalculate_centers(){
  centers={};
  for (const k in bounds){
    let coords=bounds[k];
    let maxX=-Infinity;
    let maxY=-Infinity;
    let minX=Infinity;
    let minY=Infinity;
    for (let i=0;i<coords.length;i++){
      let x=coords[i][0]/bounds_pixel_basis*current_size;
      let y=coords[i][1]/bounds_pixel_basis*current_size;
      if (x>maxX) maxX=x;
      if (x<minX) minX=x;
      if (y>maxY) maxY=y;
      if (y<minY) minY=y;
    }
    centers[k]=[(minX+maxX)/2.0,(minY+maxY)/2.0];
  }
}

let current_size=0;
function handle_resize(){
  current_size=container.clientWidth;
  canvas.width=current_size;
  canvas.height=current_size;
  recalculate_paths();
  recalculate_centers();
}

let rso = new ResizeObserver(handle_resize);
rso.observe(container);
handle_resize();

const sc2d = canvas.getContext("2d");

let selection_progress={};
for (const k in bounds){
  let av=new AnimatedValue(0.0);
  av.duration=0.5;
  av.exponent=3.0;
  av.ease_out=true;
  selection_progress[k]=av;
}

// Last selected area is at the end
let selection_sorted_keys=[];
for (const k in bounds){
  selection_sorted_keys.push(k);
}

let mouse_bounds_check={};
container.addEventListener("mousemove",(e)=>{
  let bbox=container.getBoundingClientRect();
  let localX=e.clientX-bbox.left;
  let localY=e.clientY-bbox.top;
  
  // Actual bounds check
  let mbc_last=mouse_bounds_check;
  mouse_bounds_check={};
  for (const k in bounds){
    mouse_bounds_check[k] = sc2d.isPointInPath(paths[k],localX,localY);
  }
  
  // Calculate max priority
  let max_priority=-Infinity;
  for (const k in bounds){
    if (mouse_bounds_check[k]){
      if (zone_data[k].priority>max_priority) max_priority=zone_data[k].priority;
    }
  }
  // Filter out lower-priority zones
  for (const k in bounds){
    if (zone_data[k].priority<max_priority){
      mouse_bounds_check[k] = false;
    }
  }
  
  // Transition check
  for (const k in bounds){
    let was_hit = mbc_last[k];
    let hit = mouse_bounds_check[k];
    
    if (was_hit && (!hit)){
      selection_progress[k].animate_to(0.0);
    }
    if ((!was_hit) && hit){
      selection_progress[k].animate_to(1.0);
      
      selection_sorted_keys.splice(selection_sorted_keys.indexOf(k),1);
      selection_sorted_keys.push(k);
    }
  }
  
  // Check if anything was hit
  let any_hit=false;
  for (const k in bounds){
    if (mouse_bounds_check[k]) any_hit=true;
  }
  if (any_hit) container.style.cursor="pointer";
  else container.style.cursor="unset";
});
container.addEventListener("mouseleave",(e)=>{
  for (const k in bounds){
    mouse_bounds_check[k] = false;
    selection_progress[k].animate_to(0.0);
  }
});

const font_title="bold 24px NPS";
const scale_inactive_title=0.7;
const delta_y_inactive_title=0;
const delta_y_active_title=-15;
const stroke_title=6;

const font_desc="normal 16px NPS";
const delta_y_desc=+30;
const line_height_desc=20;
const stroke_desc=6;

function color_with_alpha(color,alpha){
  return "rgb(from "+color+" r g b / "+alpha+"%)";
}
function colormix(a,b,fac){
  return "color-mix(in srgb, "+a+" "+(100-fac*100)+"%, "+b+")";
}

const sine_period_seconds=2.0;
let sine_phase=0;
function update_canvas(dt){
  
  sine_phase+=dt*(2*Math.PI/sine_period_seconds);
  sine_phase = sine_phase % (2*Math.PI);
  let sine_value=Math.sin(sine_phase);
  for (const k in bounds){
    selection_progress[k].tick(dt);
  }
  
  sc2d.clearRect(0,0,current_size,current_size);
  
  sc2d.miterLimit=2;
  sc2d.lineJoin="round";
  

  for (const k in bounds){
    let p=paths[k];
    let sp=selection_progress[k].calculate_value();
    
    let cd=category_data[zone_data[k].category];
    const color_border= cd.color_border;
    const color_fill=cd.color_fill;
    const alpha_inactive_border=cd.alpha_border_inactive;
    const alpha_active_border=cd.alpha_border_active;
    const alpha_inactive_fill=cd.alpha_fill_inactive;
    const alpha_active_fill=cd.alpha_fill_active;
    
    // bounds stroke
    sc2d.lineWidth = 2;
    sc2d.strokeStyle = color_with_alpha(color_border,
       linear_map(0,1,sp,alpha_inactive_border,alpha_active_border));
    sc2d.stroke(p);
    
    // bounds fill
    sc2d.fillStyle=color_with_alpha(color_fill,
       linear_map(0,1,sp,alpha_inactive_fill,alpha_active_fill));
    sc2d.fill(p);
  }
  
  
  for (const k of selection_sorted_keys){
    let c=centers[k];
    let x=c[0];
    let y=c[1];
    let sp=selection_progress[k].calculate_value();
    
    const ata=category_data[zone_data[k].category].alpha_title_active;
    const ati=category_data[zone_data[k].category].alpha_title_inactive;
    const alpha_title=linear_map(0,1,sp,ati,ata);
    
    const ctfa=category_data[zone_data[k].category].color_title_fill_active;
    const ctfi=category_data[zone_data[k].category].color_title_fill_inactive;
    const ctf=color_with_alpha(colormix(ctfi,ctfa,sp),alpha_title);
    const ctsa=category_data[zone_data[k].category].color_title_stroke_active;
    const ctsi=category_data[zone_data[k].category].color_title_stroke_inactive;
    const cts=color_with_alpha(colormix(ctsi,ctsa,sp),alpha_title);
    
    let text=zone_data[k]["name_"+current_lang];
    let desc=zone_data[k]["desc_"+current_lang];
    
    // Title
    let dy=linear_map(0,1,sp,delta_y_inactive_title,delta_y_active_title);
    dy+=3*sine_value*sp;
    
    let scale=linear_map(0,1,sp,scale_inactive_title,1.0);
    
    sc2d.font=font_title;
    sc2d.textAlign="center";
    sc2d.textBaseline="middle";
    
    // Shadow
    if (sp>0.0001){
      let r_mult=(1+sp*sine_value*0.08)*scale;
      sc2d.beginPath();
      sc2d.ellipse(x,y+10,30*r_mult,10*r_mult,0,0,2*Math.PI);
      sc2d.fillStyle=color_with_alpha("#000000",sp*25);
      sc2d.fill();
    }
    
    sc2d.resetTransform();
    sc2d.translate(x,y+dy);
    sc2d.scale(scale,scale);
    
    // Title Stroke
    sc2d.lineWidth = stroke_title;
    sc2d.strokeStyle = cts;
    sc2d.strokeText(text,0,0);
    
    // Title Fill
    sc2d.fillStyle=ctf;
    sc2d.fillText(text,0,0);
    sc2d.resetTransform();
    
    if (sp>0.0001){
      // Description
      sc2d.font=font_desc;
      sc2d.textAlign="center";
      sc2d.textBaseline="alphabetic";
      sc2d.resetTransform();
      sc2d.translate(x,y+delta_y_desc);
      
      let dy=0;
      let lines=desc.split("\n");
      for (let line of lines){
        line=line.trim();
        
        // Description Stroke
        sc2d.lineWidth = stroke_desc;
        sc2d.strokeStyle = color_with_alpha(cts,sp*100);
        sc2d.strokeText(line,0,dy);
        
        // Description Fill
        sc2d.fillStyle=color_with_alpha(ctf,sp*100);
        sc2d.fillText(line,0,dy);
        
        dy+=line_height_desc;
      }
      sc2d.resetTransform();
    }
    
  }
}


// This should be called every frame, from main JS.
export function animationTick(dt){
  
  update_canvas(dt);
}
